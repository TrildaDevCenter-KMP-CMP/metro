{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\ude89 Metro","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Metro is a compile-time dependency injection framework that draws heavy inspiration from Dagger, Anvil, and Kotlin-Inject. It seeks to unify their best features under one, cohesive solution while adding a few new features and implemented as a compiler plugin.</p>"},{"location":"#why-another-di-framework","title":"Why another DI framework?","text":"<p>It\u2019s felt for some time like the Kotlin community has been waiting for a library at the intersection of these different tools and features. Different tools exist for parts of these, but there\u2019s not yet been a unified solution that checks all these boxes, leaves behind some of these tools\u2019 limitations, and embraces newer features that native compiler plugins offer.</p> <p>In short, Metro stands on the shoulders of giants. It doesn\u2019t try to reinvent the wheel, it does try to make those wheels work better together.</p> <p>Note</p> <p>I\u2019m aware of the XKCD comic \ud83d\ude42, I think Metro offers a compelling feature set with interop hooks that make it easy to integrate with an existing codebase.</p>"},{"location":"#installation","title":"Installation","text":"<p>Apply the gradle plugin.</p> <pre><code>plugins {\n  id(\"dev.zacsweers.metro\") version \"x.y.z\"\n}\n</code></pre> <p>And that\u2019s it! The default configuration will add the multiplatform <code>runtime</code> artifact (which has annotations you can use) and wire it all automatically.</p> <p>You can configure custom behaviors with APIs on the <code>metro</code> DSL extension.</p> <pre><code>metro {\n  // Defines whether or not metro is enabled. Useful if you want to gate this behind a dynamic\n  // build configuration.\n  enabled = true // Default\n\n  // Enable (extremely) verbose debug logging\n  debug = false // Default\n\n  // See the kdoc on MetroPluginExtension for full details\n}\n</code></pre> <p>Snapshots of the development version are available in Sonatype\u2019s <code>snapshots</code> repository.</p>"},{"location":"#supported-platforms","title":"Supported platforms","text":"<p>The compiler plugin itself supports all multiplatform project types. The first-party annotations artifact is also multiplatform and supports all common JVM, JS, and native targets.</p>"},{"location":"#caveats","title":"Caveats","text":"<ul> <li>Kotlin compiler plugins are not a stable API! Compiled outputs from this plugin should be stable, but usage in newer versions of kotlinc are not guaranteed to be stable. That said, Metro will strive to make matching releases available quickly and test against Kotlin prereleases eagerly.</li> </ul>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>Special thanks to the many people that helped advise and offer feedback on Metro\u2019s design and implementation.</p> <ul> <li>Brian Norman</li> <li>Ralf Wondratschek</li> <li>Jesse Wilson</li> <li>Dany Santiago</li> <li>Eva Tatarka</li> <li>Bill Phillips</li> <li>Bryan Stern</li> <li>James Barr</li> <li>and many more!</li> </ul>"},{"location":"#license","title":"License","text":"<pre><code>Copyright (C) 2025 Zac Sweers\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"aggregation/","title":"Aggregation (aka \u2018Anvil\u2019)","text":"<p>Metro supports Anvil-style aggregation in graphs via <code>@ContributesTo</code> and <code>@ContributesBinding</code> annotations. As aggregation is a first-class citizen of Metro\u2019s API, there is no <code>@MergeComponent</code> annotation like in Anvil. Instead, <code>@DependencyGraph</code> defines which contribution scope it supports directly.</p> <pre><code>@DependencyGraph(scope = AppScope::class)\ninterface AppGraph\n</code></pre> <p>When a graph declares a <code>scope</code>, all contributions to that scope are aggregated into the final graph implementation in code gen.</p> <p>If a graph supports multiple scopes, use <code>additionalScopes</code>.</p> <pre><code>@DependencyGraph(\n  AppScope::class,\n  additionalScopes = [LoggedOutScope::class]\n)\ninterface AppGraph\n</code></pre> <p>Similar to kotlin-inject-anvil, <code>@DependencyGraph</code> supports excluding contributions by class. This is useful for cases like tests, where you may want to contribute a test/fake implementation that supersedes the \u201creal\u201d graph.</p> <pre><code>@DependencyGraph(\n  scope = AppScope::class,\n  excludes = [RealNetworkProviders::class]\n)\ninterface TestAppGraph\n\n@ContributesTo(AppScope::class)\ninterface TestNetworkProviders {\n  @Provides fun provideHttpClient(): TestHttpClient\n}\n</code></pre>"},{"location":"aggregation/#contributesto","title":"@ContributesTo","text":"<p>This annotation is used to contribute graph interfaces to the target scope to be merged in at graph-processing time to the final merged graph class as another supertype.</p> <pre><code>@ContributesTo(AppScope::class)\ninterface NetworkProviders {\n  @Provides fun provideHttpClient(): HttpClient\n}\n</code></pre> <p>This annotation is repeatable and can be used to contribute to multiple scopes.</p> <pre><code>@ContributesTo(AppScope::class)\n@ContributesTo(LoggedInScope::class)\ninterface NetworkProviders {\n  @Provides fun provideHttpClient(): HttpClient\n}\n</code></pre>"},{"location":"aggregation/#contributesbinding","title":"@ContributesBinding","text":"<p>This annotation is used to contribute injected classes to a target scope as a given bound type.</p> <p>The below example will contribute the <code>CacheImpl</code> class as a <code>Cache</code> type to <code>AppScope</code>.</p> <pre><code>@ContributesBinding(AppScope::class)\n@Inject\nclass CacheImpl(...) : Cache\n</code></pre> <p>For simple cases where there is a single typertype, that type is implicitly used as the bound type. If your bound type is qualified, for the implicit case you can put the qualifier on the class.</p> <pre><code>@Named(\"cache\")\n@ContributesBinding(AppScope::class)\n@Inject\nclass CacheImpl(...) : Cache\n</code></pre> <p>For classes with multiple supertypes or advanced cases where you want to bind an ancestor type, you can explicitly define this via <code>boundType</code> parameter.</p> <pre><code>@ContributesBinding(\n  scope = AppScope::class,\n  boundType = BoundType&lt;Cache&gt;()\n)\n@Inject\nclass CacheImpl(...) : Cache, AnotherType\n</code></pre> <p>Note that the bound type is defined as the type argument to <code>@ContributesBinding</code>. This allows for the bound type to be generic and is validated in FIR.</p> <p>Qualifier annotations can be specified on the <code>BoundType</code> type parameter and will take precedence over any qualifiers on the class itself.</p> <pre><code>@ContributesBinding(\n  scope = AppScope::class,\n  boundType = BoundType&lt;@Named(\"cache\") Cache&gt;()\n)\n@Inject\nclass CacheImpl(...) : Cache, AnotherType\n</code></pre> <p>This annotation is repeatable and can be used to contribute to multiple scopes.</p> <pre><code>@ContributesBinding(\n  scope = AppScope::class,\n  boundType = BoundType&lt;Cache&gt;()\n)\n@ContributesBinding(\n  scope = AppScope::class,\n  boundType = BoundType&lt;AnotherType&gt;()\n)\n@Inject\nclass CacheImpl(...) : Cache, AnotherType\n</code></pre>"},{"location":"aggregation/#contributesintosetcontributesintomap","title":"@ContributesIntoSet/@ContributesIntoMap","text":"<p>To contribute into a multibinding, use the <code>@ContributesIntoSet</code> or <code>@ContributesIntoMap</code> annotations as needed.</p> <pre><code>@ContributesIntoSet(AppScope::class)\n@Inject\nclass CacheImpl(...) : Cache\n</code></pre> <p>Same rules around qualifiers and <code>boundType()</code> apply in this scenario</p> <p>To contribute into a Map multibinding, the map key annotation must be specified on the class or <code>BoundType</code> type argument.</p> <pre><code>// Will be contributed into a Map multibinding with @StringKey(\"Networking\")\n@ContributesIntoMap(AppScope::class)\n@StringKey(\"Networking\")\n@Inject\nclass CacheImpl(...) : Cache\n\n// Or if using BoundType\n@ContributesIntoMap(\n  scope = AppScope::class,\n  boundType = BoundType&lt;@StringKey(\"Networking\") Cache&gt;()\n)\n@Inject\nclass CacheImpl(...) : Cache\n</code></pre> <p>This annotation is also repeatable and can be used to contribute to multiple scopes, multiple bound types, and multiple map keys.</p>"},{"location":"aggregation/#graphextensioncontributesgraphextension","title":"<code>@GraphExtension</code>/<code>@ContributesGraphExtension</code>","text":"<p>Not yet implemented. Please share design feedback in #165!</p>"},{"location":"aggregation/#implementation-notes","title":"Implementation notes","text":"<p>This leans on Kotlin\u2019s ability to put generic type parameters on annotations. That in turn allows for both generic bound types and to contribute map bindings to multiple map keys.</p> <p>Because it\u2019s a first-party feature, there\u2019s no need for intermediary \u201cmerged\u201d components like kotlin-inject-anvil and anvil-ksp do.</p> <p>Generated contributing interfaces are generated to the <code>metro.hints</code> package and located during graph supertype generation in FIR downstream. Any contributed bindings are implemented as <code>@Binds</code> (\u00b1 IntoSet/IntoMap/etc) annotated properties.</p>"},{"location":"bindings/","title":"Bindings","text":""},{"location":"bindings/#qualifiers","title":"Qualifiers","text":"<p>Like Dagger and KI, Metro supports qualifier annotations to allow disambiguation of types. These are applied at injection and provision sites. A qualifier annotation is any annotation annotated with <code>@Qualifier</code>. For convenience, there is an included <code>@Named</code> qualifier available in Metro\u2019s runtime that can be used too.</p> <p>A \u201ctype key\u201d in Metro is composed of a concrete type and (if any) qualifier annotation attached to it.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val int: Int\n  @Named(\"named\") val namedInt: Int\n\n  @Provides\n  fun provideInt(): Int = 3\n\n  @Provides\n  @Named(\"named\")\n  fun provideNamedInt(): Int = 4\n}\n</code></pre>"},{"location":"bindings/#binds","title":"@Binds","text":"<p>In many cases, a developer may have an implementation type on the graph that they want to expose as just its supertype.</p> <p>Like Dagger, Metro supports this with <code>@Binds</code>.</p> <p>For these cases, an abstract provider can be specified with the following conditions.</p> <ul> <li>It must be abstract</li> <li>It must define one extension receiver that is a subtype of its provided type</li> </ul> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: Message\n\n  // Bind MessageImpl as Message\n  @Binds val MessageImpl.bind: Message\n\n  @Provides\n  fun provideText(): String = \"Hello, world!\"\n}\n\n@Inject\nclass MessageImpl(val text: String) : Message\n</code></pre> <p>If you want to limit access to these from your API, you can make these declarations <code>private</code> and just return <code>this</code>. Note it\u2019s still important to annotate them with <code>@Binds</code> so that the Metro compiler understands its intent! Otherwise, it\u2019s an error to implement these declarations.</p> <p><code>@Binds</code> declarations can also declare multibinding annotations.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val messages: Message\n\n  @Binds @IntoSet val MessageImpl.bind: Message\n}\n</code></pre> <p>Note</p> <p>In theory, you can implement a provider with a getter that replicates this (similar to how kotlin-inject uses <code>@get:Provider</code> + <code>this</code>), but this will be an error in FIR because Metro can generate more efficient code at compile-time if you use <code>@Binds</code>. This is because Metro can avoid calling the function entirely and just use this information at compile-time to optimize the generated code.</p>"},{"location":"bindings/#multibindings","title":"Multibindings","text":"<p>Like Dagger and KI, Metro supports <code>Set</code> and <code>Map</code> multibindings. Multibindings are collections of bindings of a common type. Multibindings are implicitly declared by the existence of providers annotated with <code>@IntoSet</code>, <code>@IntoMap</code>, or <code>@ElementsIntoSet</code>.</p> <pre><code>@DependencyGraph\ninterface SetMultibinding {\n  // contains a set of [1, 2, 3, 4]\n  val ints: Set&lt;Int&gt;\n\n  @Provides @IntoSet fun provideInt1() = 1\n\n  @Provides @IntoSet fun provideInt2() = 2\n\n  @Provides\n  @ElementsIntoSet\n  fun provideInts() = setOf(3, 4)\n}\n</code></pre> <p>Map multibindings use <code>@IntoMap</code> and require a map key annotation. Map keys are any annotation annotated with <code>@MapKey</code>. Metro\u2019s runtime includes a number of common ones like <code>@ClassKey</code> and <code>@StringKey</code>.</p> <pre><code>@DependencyGraph\ninterface MapMultibinding {\n  // contains a map of {1:1, 2:2}\n  val ints: Map&lt;Int, Int&gt;\n\n  @Provides\n  @IntoMap\n  @IntKey(1)\n  fun provideInt1() = 1\n\n  @Provides\n  @IntoMap\n  @MapKey(2)\n  fun provideInt2() = 2\n}\n</code></pre> <p>Alternatively, they can be declared with an <code>@Multibinds</code>-annotated accessor property/function in a component. This member will be implemented by the Metro compiler and is useful for scenarios where the multibinding may be empty.</p> <pre><code>@DependencyGraph\ninterface MapMultibinding {\n  @Multibinding\n  val ints: Map&lt;Int, Int&gt;\n}\n</code></pre> <p>Multibinding collections are immutable at runtime and cannot be defined as mutable at request sites.</p> <p>Map multibindings support injecting map providers, where the value type can be wrapped in <code>Provider</code>.</p> <pre><code>@DependencyGraph\ninterface MapMultibinding {\n  @Multibinding\n  val ints: Map&lt;Int, Provider&lt;Int&gt;&gt;\n}\n</code></pre>"},{"location":"bindings/#optional-dependencies","title":"Optional Dependencies","text":"<p>Metro supports optional dependencies by leaning on Kotlin\u2019s native support for default parameter values. These are checked at injection sites and are allowed to be missing from the dependency graph when performing a lookup at validation/code-gen time.</p> <p>The below example would, since there is no <code>Int</code> binding provided, provide a message of <code>Count: -1</code>.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @Provides fun provideMessage(count: Int = -1) = \"Count: $count\"\n}\n</code></pre> <p>Dagger supports a similar feature via <code>@BindsOptionalOf</code>, but requires a separate declaration of this optional dependency to the graph.</p> <p>KI supports the same feature.</p>"},{"location":"bindings/#implementation-notes","title":"Implementation notes","text":"<p>While kotlin-inject can support this by simply invoking functions with omitted arguments, Metro has to support this in generated factories.</p> <p>To accomplish this, Metro will slightly modify how generated provider/constructor injection factory classes look compared to Dagger. Since we are working in IR, we can copy the default value expressions from the source function/constructor to the factory\u2019s newInstance and create() functions. This in turn allows calling generated graphs to simply omit absent binding arguments from their creation calls. This is a tried and tested pattern used by other first party plugins, namely kotlinx-serialization.</p> <p>There are a few cases that need to be handled here:</p> <ul> <li>Expressions may reference previous parameters or instance members. To support this, we\u2019ll transform them in IR to point at new parameters in those functions.</li> <li>Expressions may reference private instance members. To support this, Metro factories are generated as nested classes within the source class or graph.<ul> <li>This does depart from how dagger factories work, but if we ever wanted to have some sort of interop for that we could always generate bridging factory classes in the places dagger expects later.</li> </ul> </li> <li>Parameters in <code>create()</code> need to be wrapped in <code>Provider</code> calls. This means that for cases where they back-reference other parameters, those will need to be transformed into <code>invoke()</code> calls on those providers too.</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"debugging/","title":"Debugging","text":"<p>One major downside to generating IR directly is that developers cannot step into generated source code with the debugger. This is an accepted trade-off with Metro (or any other compiler plugin).</p> <p>Metro does offer a <code>debug</code> option in its plugin options/Gradle extension that will print verbose Kotlin pseudocode for all generated IR classes. This can be further tuned to print just certain classes.</p> <pre><code>metro {\n  debug.set(true)\n}\n</code></pre> <p>In the future, we could possibly explore including information in IR to synthesize call stack information similar to coroutines, but will save that for if/when it\u2019s asked for.</p>"},{"location":"debugging/#reports","title":"Reports","text":"<p>Similar to Compose, Metro supports a <code>reportsDestination</code> property in its Gradle DSL and can output various graph reports to this destination if specified. This is very much a WIP, feedback is welcome!</p> <pre><code>metro {\n  reportsDestination.set(layout.buildDirectory.dir(\"metro/reports\"))\n}\n</code></pre>"},{"location":"dependency-graphs/","title":"Dependency Graphs","text":"<p>The primary entry points in Metro are dependency graphs. These are interfaces annotated with <code>@DependencyGraph</code> and created with <code>@DependencyGraph.Factory</code> interfaces. Graphs expose types from the object graph via accessor properties or functions.</p> <p>Tip</p> <p>These are synonymous with components and <code>@Component</code>/<code>@Component.Factory</code> in Dagger and kotlin-inject.</p> <p>Tip</p> <p>\u201cAccessors\u201d in Metro are synonymous with Dagger\u2019s provision methods.</p> <p>Accessors and member injections act as roots, from which the dependency graph is resolved. Dependencies can be provided via conventional <code>@Provides</code> functions in graphs or their supertypes, constructor-injected classes, or accessed from graph dependencies.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @Provides\n  fun provideMessage(): String = \"Hello, world!\"\n}\n</code></pre> <p>Note the <code>@Provides</code> function must define an explicit return type.</p> <p>Simple graphs like this can be created via the <code>createGraph()</code> intrinsic.</p> <pre><code>val graph = createGraph&lt;AppGraph&gt;()\n</code></pre> <p>Graphs are relatively cheap and should be used freely.</p>"},{"location":"dependency-graphs/#inputs","title":"Inputs","text":"<p>Instance parameters and graph dependencies can be provided via a <code>@DependencyGraph.Factory</code> interface that returns the target graph.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(@Provides message: String): AppGraph\n  }\n}\n</code></pre> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(messageGraph: MessageGraph): AppGraph\n  }\n\n  @DependencyGraph interface MessageGraph {\n    val message: String\n\n    @Provides fun provideMessage(): String = \"Hello, world!\"\n  }\n}\n</code></pre> <p>Like Dagger, non- <code>@Provides</code> instance dependencies can be any type. Metro will treat accessor candidates of these types as usable dependencies.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(messageProvider: MessageProvider): AppGraph\n  }\n\n  interface MessageProvider {\n    val message: String\n  }\n}\n</code></pre> <p>Graph factories can be created with the <code>createGraphFactory()</code> intrinsic.</p> <pre><code>val messageGraph =\n  createGraphFactory&lt;AppGraph.Factory&gt;()\n    .create(\"Hello, world!\")\n</code></pre>"},{"location":"dependency-graphs/#scoping","title":"Scoping","text":"<p>See Scopes for more details on scopes!</p> <p>Graphs may declare a <code>scope</code> (and optionally <code>additionalScopes</code> if there are more). Each of these declared scopes act as an implicit <code>@SingleIn</code> representation of that scope for aggregation.</p> <p>For example: <pre><code>@DependencyGraph(AppScope::class)\ninterface AppGraph\n</code></pre></p> <p>Is functionally equivalent to writing the below.</p> <pre><code>@SingleIn(AppScope::class)\n@DependencyGraph(AppScope::class)\ninterface AppGraph\n</code></pre>"},{"location":"dependency-graphs/#implementation-notes","title":"Implementation Notes","text":"<p>Dependency graph code gen is designed to largely match how Dagger components are generated.</p> <ul> <li>Dependencies are traversed from public accessors and <code>inject()</code> functions.</li> <li>Metro generates Provider Factory classes for each provider. These should be generated at the same time that the provider is compiled so that their factory classes. This is for two primary purposes:<ul> <li>They can be reused to avoid code duplication</li> <li>Metro can copy default values for provider values over to the generated factory to support optional bindings. Since default values may refer to private references, we must generate these factories as nested classes.</li> </ul> </li> <li>Metro generates a graph impl class that holds all aggregated bindings and manages scoping.</li> <li>Scoped bindings are stored in provider fields backed by <code>DoubleCheck</code>.</li> <li>Reused unscoped providers instances are stored in reusable fields.</li> <li><code>@Provides</code> factory parameters are stored in a field backed by <code>InstanceFactory</code>.</li> <li>Multibindings create new collection instances every time.</li> <li>Multibinding providers are not accessible as standalone bindings.</li> </ul>"},{"location":"differences/","title":"Differences from other DI frameworks","text":""},{"location":"differences/#from-dagger","title":"\u2026from Dagger","text":"<ul> <li>There is no <code>@Module</code>. All providers run through graphs and their supertypes.</li> <li>There is no Producers support.</li> <li>There is no Hilt support, though some features are similar in the same way that Anvil\u2019s features are similar.</li> <li>There is no <code>@Reusable</code>.</li> <li>There is no <code>@BindsOptionalOf</code>.</li> <li>There is no <code>@Subcomponent</code>.</li> <li>Metro can inject private properties and functions.</li> <li>There is no <code>@BindsInstance</code>. Use <code>@Provides</code> on <code>@DependencyGraph.Factory</code> function parameters instead</li> </ul>"},{"location":"differences/#from-kotlin-inject","title":"\u2026from Kotlin-Inject","text":"<ul> <li>typealiases are not treated as implicit qualifiers.</li> <li>Dependency graph classes cannot have primary constructors, their parameters must be defined as <code>@Provides</code> or graph parameters on a <code>@DependencyGraph.Factory</code> function like Dagger.</li> <li>Higher order functions cannot be used. Instead, use <code>Provider</code> and declared <code>@AssistedFactory</code>-annotated types.</li> <li>No need for use-site targets for most annotations.</li> <li>No need for <code>@get:Provides Impl.bind: Type get() = this</code> to achieve type bindings. See the docs on <code>@Provides</code>.</li> <li>Metro can inject private properties and functions.</li> </ul>"},{"location":"differences/#from-anvil","title":"\u2026from Anvil","text":"<ul> <li>There is no <code>rank</code>.</li> <li><code>@ContributesBinding</code> requires an explicit bound type.<ul> <li>This is necessary to support generic bound types.</li> </ul> </li> </ul>"},{"location":"differences/#from-kotlin-inject-anvil","title":"\u2026from kotlin-inject-anvil","text":"<ul> <li>There is no need for <code>@CreateComponent</code> or <code>expect fun createComponent()</code> functions.</li> <li><code>@ContributesBinding</code> requires an explicit bound type.<ul> <li>This is necessary to support generic bound types.</li> </ul> </li> </ul>"},{"location":"features/","title":"Features","text":""},{"location":"features/#familiar-semantics","title":"Familiar semantics","text":"<p>Metro builds on top of established patterns from existing DI frameworks with familiar semantics like constructor injection, providers, multibindings, scopes, assisted injection, and intrinsics like Provider/Lazy.</p>"},{"location":"features/#compile-time-validation","title":"Compile-time validation","text":"<p>Like Dagger and KI, Metro validates your dependency graph at compile-time.</p>"},{"location":"features/#compile-time-firir-code-gen","title":"Compile-time FIR+IR code gen","text":"<p>Metro is implemented entirely as a Kotlin compiler plugin, primarily using FIR for error reporting and both FIR and IR for code gen. This affords significant build performance and wins compared to Dagger and KAPT/KSP in two ways:</p> <ul> <li>It avoids extra Kotlin compiler (frontend) invocations to analyze sources and generate new sources.</li> <li>It generates new code to FIR/IR directly, allowing it to be lowered directly into target platforms</li> </ul> <p>FIR/IR generation allows Metro to generate code directly into existing classes, which in turn allows it to do certain things that source-generation cannot. This includes:</p> <ul> <li>Private <code>@Provides</code> declarations.</li> <li>Injection of private member properties and functions.</li> <li>Copying + reuse of default value expressions for optional dependencies, even if they reference private APIs within the source class.</li> </ul>"},{"location":"features/#dagger-esque-code-gen-and-runtime","title":"Dagger-esque code gen and runtime","text":"<ul> <li>Metro\u2019s generated code is similar to Dagger: lean, limited duplication, and practical.</li> <li>Metro\u2019s runtime is similar to Dagger. This includes patterns like <code>DoubleCheck</code>, heavy use of factories, and an assumption that this is going to run in a large/modularized codebase.</li> </ul>"},{"location":"features/#kotlin-inject-esque-api","title":"Kotlin-Inject-esque API","text":"<p>Metro\u2019s user-facing API is similar to kotlin-inject: focused on simplicity and leaning into kotlin-language features.</p> <ul> <li>Top-level function injection</li> <li>Providers live in graph interfaces or supertypes</li> <li>Native support for optional bindings via default parameter values</li> <li>Use of Kotlin\u2019s native <code>Lazy</code> type for lazy injections</li> </ul>"},{"location":"features/#anvil-esque-aggregation","title":"Anvil-esque aggregation","text":"<p>Like Anvil, Metro supports contributing types via aggregation with annotations like <code>@ContributesTo</code>, <code>@ContributesBinding</code>, etc.</p>"},{"location":"features/#multiplatform","title":"Multiplatform","text":"<p>Metro is multiplatform and supports most major Kotlin multiplatform targets.</p>"},{"location":"features/#ide-integration","title":"IDE Integration","text":"<p>Most errors are reported in FIR, which should (eventually) be visible in the K2 IDE plugin as well.</p>"},{"location":"features/#compelling-interop","title":"Compelling interop","text":"<ul> <li>Metro supports component-level interop with Dagger and kotlin-inject. This means that Metro graphs can depend on Dagger and kotlin-inject components.</li> <li>Metro supports defining user-defined alternatives for common annotations in addition to its first-party options. This allows easier introduction to codebases using annotations from existing DI frameworks.</li> </ul>"},{"location":"generating-metro-code/","title":"Generating Metro Code","text":"<p>Java annotation processing and KSP both support multiple rounds of processing, allowing custom processors to generate new code with injection annotations that can be processed in later rounds. Anvil supported custom <code>CodeGenerator</code> implementations in K1 and anvil-ksp and kotlin-inject-anvil support specifying custom contributing annotations to allow them to intelligently defer processing to later rounds.</p> <p>Since Metro is implemented as a compiler plugin, asking users to write compiler plugins to interact with it would be a bit unwieldy. However, KSP processors that generate metro-annotated code work out of the box with it since they run before Metro\u2019s plugin does.</p> <p>If you have an existing KSP processor for a different framework, you could leverage it + custom annotations interop support described above to make them work out of the box with Metro.</p>"},{"location":"injection-types/","title":"Injection Types","text":"<p>Metro supports multiple common injection types.</p>"},{"location":"injection-types/#constructor-injection","title":"Constructor Injection","text":"<p>Most types should use constructor injection if possible. For this case, you can annotate either a class itself (if it has exactly one, primary constructor) or exactly one specific constructor.</p> <pre><code>@Inject\nclass ClassInjected\n\nclass SpecificConstructorInjection(val text: String) {\n  @Inject constructor(value: Int) : this(value.toString())\n}\n</code></pre> <p>Constructor-injected classes can be instantiated+managed entirely by Metro and encourages immutability.</p>"},{"location":"injection-types/#assisted-injection","title":"Assisted Injection","text":"<p>For types that require dynamic dependencies at instantiation, assisted injection can be used to supply these inputs. In this case - an injected constructor (or class with one constructor) must be annotated with <code>@Inject</code>, assisted parameters annotated with <code>@Assisted</code>, and a factory interface or abstract class with one single abstract function that accepts these assisted parameters and returns the target class.</p> <pre><code>@Inject\nclass HttpClient(\n  @Assisted val timeout: Duration,\n  val cache: Cache\n) {\n  @AssistedFactory\n  fun interface Factory {\n    fun create(timeout: Duration): HttpClient\n  }\n}\n</code></pre> <p>Then, the <code>@AssistedFactory</code>-annotated type can be accessed from the dependency graph.</p> <pre><code>@Inject\nclass ApiClient(httpClientFactory: HttpClient.Factory) {\n  private val httpClient = httpClientFactory.create(30.seconds)\n}\n</code></pre> <p>Like Dagger, the <code>@Assisted</code> parameters can take optional <code>value</code> keys to disambiguate matching types.</p> <pre><code>@Inject\nclass HttpClient(\n  @Assisted(\"connect\") val connectTimeout: Duration,\n  @Assisted(\"request\") val requestTimeout: Duration,\n  val cache: Cache\n) {\n  @AssistedFactory\n  fun interface Factory {\n    fun create(\n      @Assisted(\"connect\") connectTimeout: Duration,\n      @Assisted(\"request\") requestTimeout: Duration,\n    ): HttpClient\n  }\n}\n</code></pre>"},{"location":"injection-types/#automatic-assisted-factory-generation","title":"Automatic Assisted Factory Generation","text":"<p>Metro supports automatic generation of assisted factories via opt-in compiler option. If enabled, Metro will automatically generate a default factory as a nested class within the injected type.</p> <pre><code>@Inject\nclass HttpClient(\n  @Assisted timeoutDuration: Duration,\n  cache: Cache,\n) {\n  // Generated by Metro\n  @AssistedFactory\n  fun interface Factory {\n    fun create(timeoutDuration: Duration): HttpClient\n  }\n}\n</code></pre> <p>If a nested class called <code>Factory</code> is already present, Metro will do nothing.</p>"},{"location":"injection-types/#why-opt-in","title":"Why opt-in?","text":"<p>The main reason this is behind an opt-in option at the moment is because compiler plugin IDE support is rudimentary at best and currently requires enabling a custom registry flag. See the docs for how to enable IDE support.</p> <p>Because of this, it\u2019s likely better for now to just hand-write the equivalent class that Metro generates. If you still wish to proceed with using this, it can be enabled via the Gradle DSL.</p> <pre><code>metro {\n  generateAssistedFactories.set(true)\n}\n</code></pre>"},{"location":"injection-types/#member-injection","title":"Member Injection","text":"<p>Metro supports member injection to inject mutable properties or functions post-construction or into existing class instances.</p> <p>This can be useful for classes that cannot be constructor-injected, for example Android Activity classes (on older SDK versions) as well as constructor-injected classes that perhaps don\u2019t want or need to expose certain types directly in their constructors.</p> <p>Tip</p> <p>Unlike Dagger and kotlin-inject, injected members in Metro can be <code>private</code>.</p> <p>Note</p> <p>Member function injection does not (currently) support default values.</p> <pre><code>class ProfileActivity : Activity() {\n  // Property injection\n  @Inject private lateinit var db: UserDatabase\n\n  @Inject private var notifications: Notifications? = null\n\n  // Function injection\n  @Inject private fun injectUser(user: User) {\n    // ...\n  }\n}\n</code></pre> <p>Like Dagger, these classes can be injected via multiple avenues.</p>"},{"location":"injection-types/#1-in-constructor-injected-types-inject-annotated-members-are-injected-automatically","title":"1. In constructor-injected types, <code>@Inject</code>-annotated members are injected automatically.","text":"<pre><code>// Injection with constructor injection\n@Inject\nclass ProfileInjector(\n  // ...\n) {\n  // Automatically injected during constructor injection\n  @Inject private fun injectUser(value: String) {\n    // ...\n  }\n}\n</code></pre> <p>In these cases, Metro will automatically inject these members automatically and immediately after instantiation during constructor injection.</p>"},{"location":"injection-types/#2-exposing-a-fun-injecttarget-profileactivity-function-on-the-graph","title":"2. Exposing a <code>fun inject(target: ProfileActivity)</code> function on the graph","text":"<pre><code>// Graph inject() functions\n@DependencyGraph\ninterface AppGraph {\n  // ...\n\n  fun inject(target: ProfileActivity)\n}\n\n// Somewhere else\nval graph = createGraph&lt;AppGraph&gt;()\ngraph.inject(profileActivity)\n</code></pre> <p>With this option, you can call <code>graph.inject(target)</code> on the instance with members you wish to inject.</p>"},{"location":"injection-types/#3-requesting-a-membersinjector-instance-from-the-dependency-graph","title":"3. Requesting a <code>MembersInjector</code> instance from the dependency graph.","text":"<pre><code>// Injection with MembersInjector\n@Inject\nclass ProfileInjector(\n  private val injector: MembersInjector&lt;ProfileActivity&gt;\n) {\n  fun performInjection(activity: ProfileActivity) {\n    injector.inject(activity)\n  }\n}\n</code></pre> <p>Like Dagger, option #3 is accomplished via <code>MembersInjector</code> interface at runtime and in code gen. This should be reserved for advanced use cases.</p>"},{"location":"injection-types/#implementation-notes","title":"Implementation notes","text":"<ul> <li>Property accessors don\u2019t use <code>get</code>/<code>set</code> names in <code>inject{name}()</code> function names.</li> <li>MembersInjector classes are generated as nested classes, allowing private member access.<ul> <li>This includes parent classes\u2019 private members (!!)</li> </ul> </li> <li>Optional bindings are not supported for injected member functions currently, but may be possible in the future.</li> </ul>"},{"location":"injection-types/#top-level-function-injection","title":"Top-level Function Injection","text":"<p>Like KI, Metro supports top-level function injection (behind an opt-in compiler option). The primary use case for this is composable functions and standalone applications that run from <code>main</code> functions.</p> <pre><code>@Inject\nfun App(message: String) {\n  // ...\n}\n</code></pre> <p>To do this, Metro\u2019s FIR plugin will generate a concrete type that acts as a bridge for this function.</p> <pre><code>@Inject\nclass AppClass(\n  private val message: Provider&lt;String&gt;\n) {\n  operator fun invoke() {\n    App(message())\n  }\n}\n</code></pre> <p>Because it\u2019s generated in FIR, this type will be user-visible in the IDE and can then be referenced in a graph.</p> <p>Note that this feature requires enabling third party FIR plugins in the IDE to fully work. It will compile without it, but generated wrapper classes will be red/missing in the IDE.</p> <p>Note</p> <p>The generated class is called <code>&lt;function name&gt;</code> + <code>Class</code> because of a limitation in the Kotlin compiler. TODO Link issue?</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val app: AppClass\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(message: String): AppGraph\n  }\n}\n\n// Usage\nval app = createGraphFactory&lt;AppGraph.Factory&gt;()\n  .create(\"Hello, world!\")\n  .app\n\n// Run the app\napp()\n</code></pre> <p>To add assisted parameters, use <code>@Assisted</code> on the parameters in the function description. These will be propagated accordingly.</p> <pre><code>@Inject\nfun App(@Assisted message: String) {\n  // ...\n}\n\n// Generates...\n@Inject\nclass AppClass {\n  operator fun invoke(message: String) {\n    App(message)\n  }\n}\n\n// Usage\nval app = createGraph&lt;AppGraph&gt;()\n  .app\n\n// Run the app\napp(\"Hello, world!\")\n</code></pre> <p>This is particularly useful for Compose, and <code>@Composable</code> functions will be copied over accordingly.</p> <pre><code>@Inject\n@Composable\nfun App(@Assisted message: String) {\n  // ...\n}\n\n// Generates...\n@Inject\nclass AppClass {\n  @Composable\n  operator fun invoke(message: String) {\n    App(message)\n  }\n}\n\n// Usage\nval App = createGraph&lt;AppGraph&gt;()\n  .app\n\n// Call it in composition\nsetContent {\n  App(\"Hello, world!\")\n}\n</code></pre> <p>Similarly, if the injected function is a <code>suspend</code> function, the <code>suspend</code> keyword will be ported to the generated <code>invoke()</code> function too.</p>"},{"location":"injection-types/#why-opt-in_1","title":"Why opt-in?","text":"<p>There are two reasons this is behind an opt-in option at the moment.</p> <ol> <li>Generating top-level declarations in Kotlin compiler plugins (in FIR specifically) is not    currently compatible with incremental compilation.</li> <li>IDE support is rudimentary at best and currently requires enabling a custom registry flag.    See the docs for how to enable IDE support.</li> </ol> <p>Because of this, it\u2019s likely better for now to just hand-write the equivalent class that Metro generates. If you still wish to proceed with using this, it can be enabled via the Gradle DSL.</p> <pre><code>metro {\n  enableTopLevelFunctionInjection.set(true)\n}\n</code></pre>"},{"location":"injection-types/#implementation-notes_1","title":"Implementation notes","text":"<p>This is fairly different from kotlin-inject\u2019s typealias approach. This is necessary because Metro doesn\u2019t use higher order function types or typealiases as qualifiers.</p>"},{"location":"installation/","title":"Installation","text":"<p>Metro is primarily applied via its companion Gradle plugin.</p> <pre><code>plugins {\n  kotlin(\"multiplatform\") // or jvm, android, etc\n  id(\"dev.zacsweers.metro\")\n}\n</code></pre> <p>\u2026and that\u2019s it! This will add metro\u2019s runtime dependencies and do all the necessary compiler plugin wiring.</p> <p>If applying in other build systems, apply it however that build system conventionally applies Kotlin compiler plugins. For example with Bazel:</p> <pre><code>load(\"@rules_kotlin//kotlin:core.bzl\", \"kt_compiler_plugin\")\nload(\"@rules_kotlin//kotlin:jvm.bzl\", \"kt_jvm_library\")\n\nkt_compiler_plugin(\n    name = \"metro_plugin\",\n    compile_phase = True,\n    id = \"dev.zacsweers.metro.compiler\",\n    options = {\n        \"enabled\": \"true\",\n        \"debug\": \"false\",\n    },\n    deps = [\n        \"@maven//:dev_zacsweers_metro_compiler\",\n    ],\n)\n\nkt_jvm_library(\n    name = \"sample\",\n    # The SampleGraph class is annotated with @DependencyGraph\n    srcs = [\"SampleGraph.kt\"],\n    plugins = [\n        \":metro_plugin\",\n    ],\n    deps = [\n        \"@maven//:dev_zacsweers_metro_runtime_jvm\",\n    ],\n)\n</code></pre>"},{"location":"installation/#ide-support","title":"IDE Support","text":"<p>The K2 Kotlin IntelliJ plugin supports running third party FIR plugins in the IDE, but this feature is hidden behind a flag. Some Metro features can take advantage of this, namely diagnostic reporting directly in the IDE and some opt-in features to see generated declarations. </p> <p>To enable it, do the following:</p> <ol> <li>Enable K2 Mode for the Kotlin IntelliJ plugin.</li> <li>Open the Registry</li> <li>Set the <code>kotlin.k2.only.bundled.compiler.plugins.enabled</code> entry to <code>false</code>.</li> </ol> <p>Note that support is unstable and subject to change.</p>"},{"location":"interop/","title":"Interop","text":""},{"location":"interop/#annotations","title":"Annotations","text":"<p>Metro supports user-defined annotations for common annotations. This means that a user doesn\u2019t necessarily have to use Metro\u2019s annotations if they\u2019re introducing it to an existing codebase. Support varies depending on the annotation\u2019s use case.</p> <p>Compile-only annotations are mostly supported. This includes the following:</p> <ul> <li><code>@Assisted</code></li> <li><code>@AssistedFactory</code></li> <li><code>@AssistedInject</code></li> <li><code>@Binds</code></li> <li><code>@BindsInstance</code></li> <li><code>@ContributesTo</code></li> <li><code>@ContributesBinding</code></li> <li><code>@ElementsIntoSet</code></li> <li><code>@DependencyGraph</code></li> <li><code>@DependencyGraph.Factory</code></li> <li><code>@Inject</code></li> <li><code>@IntoMap</code></li> <li><code>@IntoSet</code></li> <li><code>@MapKey</code></li> <li><code>@Multibinds</code></li> <li><code>@Provides</code></li> <li><code>@Qualifier</code></li> <li><code>@Scope</code></li> </ul> <p>These are configurable via Metro\u2019s Gradle extension.</p> <pre><code>metro {\n  interop {\n    assisted.add(\"dagger/assisted/Assisted\")\n  }\n}\n</code></pre> <p>For Dagger and KI specifically, there are convenience helper functions.</p> <pre><code>metro {\n  interop {\n    includeDagger()\n    includeKotlinInject()\n    includeAnvil()\n  }\n}\n</code></pre> <p><code>@DependencyGraph</code> is replaceable but your mileage may vary if you use Anvil or modules, since Metro\u2019s annotation unifies Anvil\u2019s <code>@MergeComponent</code> functionality and doesn\u2019t support modules.</p> <p>Similarly, <code>@ContributesBinding</code> is replaceable but there are not direct analogues for Anvil\u2019s <code>@ContributesMultibinding</code> or kotlin-inject-anvil\u2019s <code>@ContributesBinding(multibinding = \u2026)</code> as these annotations are implemented as <code>@ContributesInto*</code> annotations in Metro. Also - <code>boundType</code> in metro uses a more flexible mechanism to support generics.</p>"},{"location":"interop/#components","title":"Components","text":"<p>Metro graphs can interop with components generated by Dagger and Kotlin-Inject. These work exclusively through their public accessors and can be depended on like any other graph dependency.</p> <pre><code>@DependencyGraph\ninterface MetroGraph {\n  val message: String\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(\n      daggerComponent: DaggerComponent\n    ): MetroGraph\n  }\n}\n\n@dagger.Component\ninterface DaggerComponent {\n  val message: String\n\n  @dagger.Component.Factory\n  fun interface Factory {\n    fun create(@Provides message: String): DaggerComponent\n  }\n}\n</code></pre> <p>Conversely, kotlin-inject and Dagger components can also depend on Metro graphs.</p> <pre><code>@DependencyGraph\ninterface MessageGraph {\n  val message: String\n\n  // ...\n}\n\n// Dagger\n@Component(dependencies = [MetroGraph::class])\ninterface DaggerComponent {\n  val message: String\n\n  @Component.Factory\n  fun interface Factory {\n    fun create(messageGraph: MessageGraph): DaggerComponent\n  }\n}\n\n// kotlin-inject\n@Component\nabstract class KotlinInjectComponent(\n  @Component val messageGraph: MessageGraph\n) {\n  abstract val message: String\n}\n</code></pre>"},{"location":"interop/#runtime","title":"Runtime","text":"<p>Enabling dagger interop also enables more advanced runtime interop with Dagger/Javax/Jakarta\u2019s <code>Provider</code>/<code>Lazy</code> types.</p> <pre><code>metro {\n  interop {\n    includeDagger()\n  }\n}\n</code></pre> <p>This specifically enables two features.</p> <ol> <li>Interop with Dagger/Javax/Jakarta\u2019s <code>Provider</code> and <code>Lazy</code> runtime intrinsics.</li> <li>Interop with generated Dagger factories for constructor-injected and assisted-injected classes. This means that an upstream class that was processed with the dagger compiler and has a generated Java factory class for a constructor injected class can be reused by Metro natively.</li> </ol> <p>Note this also automatically adds an extra <code>interop-dagger</code> dependency to support this scenario.</p>"},{"location":"metro-intrinsics/","title":"Metro Intrinsics","text":"<p>Like Dagger, Metro supports injection of bindings wrapped in intrinsic types. Namely - <code>Provider</code> and <code>Lazy</code>. These are useful for deferring creation/initialization of dependencies. These only need to be requested at the injection site, Metro\u2019s code gen will generate all the necessary stitching to fulfill that request.</p>"},{"location":"metro-intrinsics/#provider","title":"<code>Provider</code>","text":"<p><code>Provider</code> is like Dagger\u2019s <code>Provider</code> \u2014 it is a simple interface who\u2019s <code>invoke()</code> call returns a new instance every time. If the underlying binding is scoped, then the same (scoped) instance is returned every time <code>invoke()</code> is called.</p> <pre><code>@Inject\nclass HttpClient(val cacheProvider: Provider&lt;Cache&gt;) {\n  fun createCache() {\n    val cache = cacheProvider()\n  }\n}\n</code></pre>"},{"location":"metro-intrinsics/#lazy","title":"<code>Lazy</code>","text":"<p><code>Lazy</code> is Kotlin\u2019s standard library <code>Lazy</code>. It lazily computes a value the first time it\u2019s evaluated and is thread-safe.</p> <pre><code>@Inject\nclass HttpClient(val cacheProvider: Lazy&lt;Cache&gt;) {\n  fun createCache() {\n    // The value is computed once and cached after\n    val cache = cacheProvider.value\n  }\n}\n</code></pre> <p>Note that <code>Lazy</code> is different from scoping in that it is confined to the scope of the injected type, rather than the component instance itself. There is functionally no difference between injecting a <code>Provider</code> or <code>Lazy</code> of a scoped binding. A <code>Lazy</code> of a scoped binding can still be useful to defer initialization. The underlying implementation in Metro\u2019s <code>DoubleCheck</code> prevents double memoization in this case.</p> <p>Why doesn\u2019t <code>Provider</code> just use a property like <code>Lazy</code>?</p> <p>A property is appropriate for <code>Lazy</code> because it fits the definition of being a computed value that is idempotent for repeat calls. Metro opts to make its <code>Provider</code> use an <code>invoke()</code> function because it does not abide by that contract.</p>"},{"location":"metro-intrinsics/#providers-of-lazy","title":"Providers of Lazy","text":"<p>Metro supports combining <code>Provider</code> and <code>Lazy</code> to inject <code>Provider&lt;Lazy&lt;T&gt;&gt;</code>. On unscoped bindings this means the provider will return a new deferrable computable value (i.e. a new Lazy). Meanwhile <code>Lazy&lt;Provider&lt;T&gt;&gt;</code> is meaningless and not supported.</p>"},{"location":"multiplatform/","title":"Multiplatform","text":"<p>Should Just Work\u2122\ufe0f! The runtime and code gen have been implemented to be entirely platform-agnostic so far.</p> <p>There is one issue in the repo right now where the compiler appears to have a bug with generated FIR declarations where it doesn\u2019t deserialize them correctly on non-JVM targets. Waiting for feedback from JB.</p> <p>When mixing contributions between common and platform-specific source sets, you must define your final <code>@DependencyGraph</code> in the platform-specific code. This is because a graph defined in commonMain wouldn\u2019t have full visibility of contributions from platform-specific types. A good pattern for this is to define your canonical graph in commonMain without a <code>@DependencyGraph</code> annotation and then a <code>{Platform}{Graph}</code> type in the platform source set that extends it and does have the <code>@DependencyGraph</code>. Metro automatically exposes bindings of the base graph type on the graph for any injections that need it.</p> <pre><code>// In commonMain\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n\n// In jvmMain\n@DependencyGraph\ninterface JvmAppGraph : AppGraph {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient(Netty)\n}\n\n// In androidMain\n@DependencyGraph\ninterface AndroidAppGraph : AppGraph {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient(OkHttp)\n}\n</code></pre>"},{"location":"provides/","title":"<code>@Provides</code>","text":"<p>Providers can be defined in graphs or supertypes that graphs extend. Defining them in supertypes allows for them to be reused across multiple graphs and organize providers into logic groups. This is similar to how modules in Dagger work.</p> <pre><code>interface NetworkProviders {\n  @Provides\n  fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph\ninterface AppGraph : NetworkProviders\n</code></pre> <p>Providers should be <code>private</code> by default.</p> <p>Tip</p> <p>It\u2019s recommended to not call providers from each other.</p>"},{"location":"provides/#overrides","title":"Overrides","text":"<p>It is an error to override providers declarations. While it can be enticing for testing reasons to try to replicate Dagger 1\u2019s module overrides, it quickly becomes difficult to reason about in code gen.</p> <ul> <li>What if you override with sub/supertypes?</li> <li>What if your override\u2019s implementation needs different dependencies?</li> </ul> <p>To the testing end, it is recommended to instead leverage the <code>DependencyGraph.excludes</code> + <code>ContributesTo.replaces</code> APIs in merging.</p> <pre><code>// Don't do this pattern!\ninterface NetworkProviders {\n  @Provides\n  fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph\ninterface TestAppGraph : NetworkProviders {\n  // This will fail to compile\n  override fun provideHttpClient(): HttpClient = TestHttpClient()\n}\n</code></pre>"},{"location":"provides/#companion-providers","title":"Companion Providers","text":"<p>Providers can alternatively be implemented in <code>companion object</code>s for staticization.</p> <pre><code>interface MessageGraph {\n  val message: String\n  companion object {\n    @Provides\n    private fun provideMessage(): String = \"Hello, world!\"\n  }\n}\n</code></pre>"},{"location":"provides/#implementation-notes","title":"Implementation Notes","text":"<p>private interface functions are not usually visible to downstream compilations in IR. To work around this, Metro will use a new API in Kotlin 2.1.20 to add custom metadata to the parent class to denote these private providers\u2019 existence and where to find them.</p>"},{"location":"scopes/","title":"Scopes","text":"<p>Like Dagger and KI, Metro supports scopes to limit instances of types on the dependency graph. A scope is any annotation annotated with <code>@Scope</code>, with a convenience <code>@Singleton</code> scope available in Metro\u2019s runtime.</p> <p>Scopes must be applied to either the injected class or the provider function providing that binding. They must also match the graph that they are used in.</p> <pre><code>@Singleton\n@DependencyGraph\nabstract class AppGraph {\n  private var counter = 0\n\n  abstract val count: Int\n\n  @Singleton @Provides fun provideCount() = counter++\n}\n</code></pre> <p>In the above example, multiple calls to <code>AppGraph.count</code> will always return 0 because the returned value from <code>provideCount()</code> will be cached in the <code>AppGraph</code> instance the first time it\u2019s called.</p> <p>It is an error for an unscoped graph to access scoped bindings.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  // This is an error!\n  val exampleClass: ExampleClass\n}\n\n@Singleton\n@Inject\nclass ExampleClass\n</code></pre> <p>It is also an error for a scoped graph to access scoped bindings whose scope does not match.</p> <pre><code>@Scope annotation class UserScope\n\n@Singleton\n@DependencyGraph\ninterface AppGraph {\n  // This is an error!\n  val exampleClass: ExampleClass\n}\n\n@UserScope\n@Inject\nclass ExampleClass\n</code></pre> <p>Like Dagger, graphs can have multiple scopes that they support.</p> <pre><code>@Scope annotation class SingleIn(val scope: KClass&lt;*&gt;)\n\n@Singleton\n@SingleIn(AppScope::class)\n@DependencyGraph\ninterface AppGraph {\n  // This is ok\n  val exampleClass: ExampleClass\n}\n\n@SingleIn(AppScope::class)\n@Inject\nclass ExampleClass\n</code></pre>"},{"location":"validation-and-error-reporting/","title":"Validation &amp; Error Reporting","text":"<p>Common programmer/usage errors are implemented in FIR. This should allow errors to appear directly in the IDE, offering the best and fastest feedback loop for developers writing their code.</p> <p>TODO IDE screenshot example</p> <p>Dependency graph validation is performed at the per-graph level. Metro seeks to report binding validation errors at least on par with Dagger, if not better.</p> <pre><code>ExampleGraph.kt:6:1 [Metro/DependencyCycle] Found a dependency cycle:\n    kotlin.Int is injected at\n        [test.ExampleGraph] test.ExampleGraph.provideString(..., int)\n    kotlin.String is injected at\n        [test.ExampleGraph] test.ExampleGraph.provideDouble(..., string)\n    kotlin.Double is injected at\n        [test.ExampleGraph] test.ExampleGraph.provideInt(..., double)\n    kotlin.Int is injected at\n        [test.ExampleGraph] test.ExampleGraph.provideString(..., int)\n</code></pre> <p>Binding errors take learnings from Dagger and report fully qualified references that IDEs like IntelliJ can usually autolink.</p> <pre><code>ExampleGraph.kt:6:1 [Metro/GraphDependencyCycle] Dependency graph dependency cycle detected! The below graph depends on itself.\n    test.CharSequenceGraph is requested at\n        [test.CharSequenceGraph] test.CharSequenceGraph.Factory.create()\n</code></pre> <p>Note that binding graph resolution currently only happens in the compiler IR backend, but maybe someday we can move this to FIR to get errors in the IDE.</p>"}]}